# Лабораторная работа 1
Реализация абстрактного типа данных – полиморфной коллекции на 
основе динамического массива. 

---
**Номер варианта**: _26_
**Тип коллекции**: _Динамический массив_
**Типы хранимых элементов**:
- _Вещественные числа_
- _Строки_
**Операции**:
- _Конкатенация массивов_
- _Сортировка_
- _Map_
- _Where_

___
## Описание
Структура `dynamic_array`. Содержит 3 поля: 
- `capacity` -- размер выделенного блока памяти (ёмкость)
- `size` -- размер занимаемого блока памяти
- `list` -- список указателей на `void`. 
  **Указатель `*void` может указывать на любую переменную, которая не объявлена с const помощью или volatile. 

### Основные атомарные функции:
- `dynamic_array* newList()` -- создаёт динамический массив ёмкостью 5, размером 0
- `void resize(dynamic_array*)` -- увеличивает ёмкость на 5 единиц
- `void addString(dynamic_array*, char*)` -- добавляет в динамический массив строку
- `void addDouble(dynamic_array*, double)` -- добавляет в динамический массив вещественное число (_как строку_)
- `void freeList(dynamic_array*, int)` -- освобождает память, выделенную под динамический массив + выдаёт code_Error, если требуется
- `int isString(char*)` -- проверка, является ли строка строкой (1 = да, 0 = нет)
- `int isDouble(char*)` -- проверка, является ли строка числом (1 = да, 0 = нет)
- `void printList(dynamic_array*)` -- выводит динамический массив (всё выводится как строки)

> В программе специально не используется `<stdbool.h>` и тип `bool`

### Основные и вспомогательные функции взаимодействия: 
- `dynamic_array* concatenation(dynamic_array*, dynamic_array*)` -- Функция конкатенации двух динамических массивов, реализованных через структуру  `dynamic_array*`
- `void mapString(void (*func)(char*), dynamic_array*)` -- Функция `map`, применяемая к строкам (игнорирует числа). 
- `void mapDouble(double (*func)(double), dynamic_array*)` -- Функция `map`, применяемая к числам (игнорирует строки) 
- `dynamic_array* where(int (*func)(char*), dynamic_array*)` -- Функция `where`: 
	`where(h, l) -> l', где (a ∈ l') ⇔ (a ∈ l) ^ (h(a) == True)` 
- `dynamic_array* sort(dynamic_array*, int param1, int param2)` -- Функция сортировки динамического массива. 
	- `param1 = 0`: только числа
	- `param1 = 1`: только строки
	- `param1 = 2`: сначала строки, потом числа
	- `param1 = 3`: сначала числа, потом строки
	- `param2 = 0`: убывание
	- `param2 = 1`: возрастание
- `void sortString(dynamic_array* darr, int)` -- вспомогательная функция для функции `sort`
- `void sortDouble(dynamic_array* darr, int)` -- вспомогательная функция для функции `sort`
- `int compareDouble1(void* a, void* b)`, `int compareDouble0(void* a, void* b)`, `int compareString1(void* a, void* b)`, `int compareString0(void* a, void* b)` -- вспомогательные функции попарного сравнения элементов динамического массива.
- `dynamic_array* fragmentString(dynamic_array* darr)` -- создает динамический подмассив динамического массива, состоящий только из его собственных строк.
- `dynamic_array* fragmentDouble(dynamic_array* darr)` -- создает динамический подмассив динамического массива, состоящий только из его собственных чисел.
